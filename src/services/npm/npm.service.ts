import DependencyModel, {Dependency} from "../../models/dependency.model.js";
import dependencyType from "../../enums/dependencyType.js";
import CveModel, {Cve, DependencyCve} from "../../models/cve.model.js";
import {satisfies} from "semver";
import {randomUUID} from "crypto";
import vulnerabilityLevel from "../../enums/vulnerabilityLevel.js";
import CveService from "../cve.service.js";
import NpmRegistryService, {Advisory} from "./npm-registry.service.js";
import GithubService from "./github.service.js";

interface Result {
    create: Omit<DependencyCve, 'id'>[];
    delete: string[];
}

class NpmService {
    public async update(): Promise<void> {
        const dependencies = await DependencyModel.findAllByType(dependencyType.NPM);
        const [dependencyCveLookup, cveLookup] = await CveModel.findAllByDependencyIds(dependencies.map(dependency => dependency.id))
            .then(cves => CveService.getLookups(cves));

        const errors: Set<string> = new Set();
        let advisories: Record<string, Advisory[]> = {};
        for (const requestBody of this.generateRequestBodies(dependencies)) {
            const newAdvisories = await NpmRegistryService.getAdvisories(requestBody)
                .catch((e) => {
                    console.log(e);
                });

            if (!newAdvisories) {
                Object.keys(requestBody).forEach(errors.add, errors);
                continue;
            }

            advisories = {
                ...advisories,
                ...newAdvisories,
            };
        }

        const newCveLookup = new Map<string, Cve>();
        const updatedDependencies: Dependency[] = [];
        const result: Result = {
            create: [],
            delete: [],
        };

        for (const dependency of dependencies) {
            if (errors.has(dependency.name))
                continue;

            const existingCves = dependencyCveLookup.get(dependency.id) ?? [];
            const newCves: Cve[] = [];

            for (const advisory of advisories[dependency.name] ?? []) {
                if (satisfies(dependency.version, advisory.vulnerable_versions)) {
                    const advisoryId = advisory.id.toString();
                    const title = newCveLookup.get(advisoryId)?.title ?? await GithubService.getName(advisory.url)
                        .catch((e) => {
                            console.log(e);
                            return advisoryId;
                        });

                    const cve: Cve = newCveLookup.get(advisoryId) ?? {
                        id: cveLookup.get(advisory.title)?.cve_id ?? cveLookup.get(advisory.title)?.cve_id ?? randomUUID(),
                        title: title,
                        summary: advisory.title,
                        link: advisory.url,
                        vulnerability_level: NpmRegistryService.getVulnerabilityLevel(advisory.cvss.score),
                    };
                    newCves.push(cve);
                    newCveLookup.set(advisoryId, cve);
                }
            }

            let highestLevel = vulnerabilityLevel.NONE;
            for (const newCve of newCves) {
                const index = existingCves.findIndex(cve => cve.title === newCve.title);
                if (index !== -1)
                    existingCves.splice(index, 1);
                else
                    result.create.push({
                        dependency_id: dependency.id,
                        cve_id: newCve.id,
                    });

                highestLevel = CveService.getHighestVulnerabilityLevel(highestLevel, newCve.vulnerability_level);
            }

            result.delete.push(...existingCves.map(cve => cve.cve_id));

            if (dependency.vulnerability_level !== highestLevel)
                updatedDependencies.push({...dependency, vulnerability_level: highestLevel});
        }

        if (result.delete.length)
            await CveModel.deleteByIds(result.delete);

        if (result.create.length)
            await CveModel.insert(result.create, Array.from(newCveLookup.values()));

        if (updatedDependencies.length)
            await DependencyModel.update(updatedDependencies);
    }

    private generateRequestBodies(dependencies: Dependency[]): Record<string, string[]>[] {
        const dependencyMap: Record<string, string[]> = {};

        for (const dependency of dependencies) {
            const entry = dependencyMap[dependency.name];
            if (entry)
                entry.push(dependency.version);
            else
                dependencyMap[dependency.name] = [dependency.version];
        }

        const uniqueDependencies = Object.keys(dependencyMap);
        const bodyLength = 50;
        const requestBodies: Record<string, string[]>[] = [];
        for (let i = 0; i < uniqueDependencies.length; i += bodyLength) {
            const chunkDependencyNames = uniqueDependencies.slice(i, i + bodyLength);
            const chunkDependencies: Record<string, string[]> = {};

            for (const chunkDependencyName of chunkDependencyNames)
                chunkDependencies[chunkDependencyName] = dependencyMap[chunkDependencyName];

            requestBodies.push(chunkDependencies);
        }

        return requestBodies;
    }
}

export default new NpmService();
