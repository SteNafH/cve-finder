import DependencyModel, {Dependency} from "../../models/dependency.model.js";
import dependencyType from "../../enums/dependencyType.js";
import CveModel, {Cve, DependencyCve} from "../../models/cve.model.js";
import PackagistService, {Advisory} from "./packagist.service.js";
import {satisfies} from "semver";
import {randomUUID} from "crypto";
import vulnerabilityLevel from "../../enums/vulnerabilityLevel.js";
import CveService from "../cve.service.js";

class ComposerService {
    public async update(): Promise<void> {
        const dependencies = await DependencyModel.findAllByType(dependencyType.COMPOSER);
        const [dependencyCveLookup, cveLookup] = await CveModel.findAllByDependencyIds(dependencies.map(dependency => dependency.id))
            .then(cves => CveService.getLookups(cves));

        const errors: Set<string> = new Set();
        let advisories: Record<string, Advisory[]> = {};
        for (const requestBody of this.generateRequestBodies(dependencies)) {
            const newAdvisories = await PackagistService.getAdvisories(requestBody)
                .catch((e) => {
                    console.log(e);
                });

            if (!newAdvisories) {
                requestBody.forEach(errors.add, errors);
                continue;
            }

            advisories = {
                ...advisories,
                ...newAdvisories,
            };
        }

        const newCveLookup = new Map<string, Cve>();
        const updatedDependencies: Dependency[] = [];
        const result: Result<Omit<DependencyCve, 'id'>> = {
            create: [],
            delete: [],
        };

        for (const dependency of dependencies) {
            if (errors.has(dependency.name))
                continue;

            const existingCves = dependencyCveLookup.get(dependency.id) ?? [];
            const newCves: Cve[] = [];

            for (const advisory of advisories[dependency.name] ?? []) {
                //composer/semver is different to npm semver
                const affectedVersion = advisory.affectedVersions.replaceAll(',', ' ').replaceAll('|', '||');
                if (satisfies(dependency.version, affectedVersion)) {
                    const advisoryId = advisory.cve ?? advisory.advisoryId;
                    const cve: Cve = newCveLookup.get(advisoryId) ?? {
                        id: cveLookup.get(advisoryId)?.cve_id ?? randomUUID(),
                        title: advisoryId,
                        summary: advisory.title,
                        link: advisory.link,
                        vulnerability_level: PackagistService.getVulnerabilityLevel(advisory.severity),
                    };
                    newCves.push(cve);
                    newCveLookup.set(advisoryId, cve);
                }
            }

            let highestLevel = vulnerabilityLevel.NONE;
            for (const newCve of newCves) {
                const index = existingCves.findIndex(cve => cve.title === newCve.title);
                if (index !== -1)
                    existingCves.splice(index, 1);
                else
                    result.create.push({
                        dependency_id: dependency.id,
                        cve_id: newCve.id,
                    });

                highestLevel = CveService.getHighestVulnerabilityLevel(highestLevel, newCve.vulnerability_level);
            }

            result.delete.push(...existingCves.map(cve => cve.cve_id));

            if (dependency.vulnerability_level !== highestLevel)
                updatedDependencies.push({...dependency, vulnerability_level: highestLevel});
        }

        if (result.delete.length)
            await CveModel.deleteByIds(result.delete);

        if (result.create.length)
            await CveModel.insert(result.create, Array.from(newCveLookup.values()));

        if (updatedDependencies.length)
            await DependencyModel.update(updatedDependencies);
    }

    private generateRequestBodies(dependencies: Dependency[]): string[][] {
        const uniqueDependencies = Array.from(new Set(dependencies.map(dependency => dependency.name)));
        const bodyLength = 10;

        const requestBodies: string[][] = [];
        for (let i = 0; i < uniqueDependencies.length; i += bodyLength)
            requestBodies.push(uniqueDependencies.slice(i, i + bodyLength));

        return requestBodies;
    }
}

export default new ComposerService();
